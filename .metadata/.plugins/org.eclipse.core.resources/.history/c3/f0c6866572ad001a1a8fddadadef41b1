/*
 * generated by Xtext 2.21.0
 */
package mdsd.validation;


import java.util.*;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import mdsd.rPG.AfterE;
import mdsd.rPG.AltAttribute;
import mdsd.rPG.Attribute;
import mdsd.rPG.Attributes;
import mdsd.rPG.Buff;
import mdsd.rPG.Death;
import mdsd.rPG.Declaration;
import mdsd.rPG.Effects;
import mdsd.rPG.Entities;
import mdsd.rPG.Entity;
import mdsd.rPG.Locations;
import mdsd.rPG.Move;
import mdsd.rPG.MoveE;
import mdsd.rPG.Moves;
import mdsd.rPG.RPGPackage;
import mdsd.rPG.Relations;
import mdsd.rPG.SystemRPG;
import mdsd.rPG.Team;
import mdsd.rPG.Teams;
import mdsd.rPG.Type;
import mdsd.rPG.TypeExpression;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RPGValidator extends AbstractRPGValidator {
	
	public static final String INVALID_NAME = "invalidName";
	public static final String UNSUPPORTED_OPERATION = "unsupportedOperation";
	public static final String MISSING_DECLARATION = "missingDeclaration";
	public static final String DUPLICATED_DECLARATION = "duplicatedDeclaration";
	public static final String EMPTY_ENTTIY_ATTRIBUTES = "emptyEntityAttributes";
	public static final String INCORRECT_TEAM_COUNT = "incorrectTeamCount";
	public static final String INDISTINCT_ATTRIBUTES = "indistinctAttributes";
	
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RPGPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	@Check
	public void checkEntityStartsWithCapital(Entity entity) {
		if (!Character.isUpperCase(entity.getName().charAt(0))) {
			warning("The name of an entity should be a capital letter.",  RPGPackage.Literals.ENTITY__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkGameStartsWithCapital(SystemRPG sysrpg) {
		if (!Character.isUpperCase(sysrpg.getName().charAt(0))) {
			error("The name of the game should start with a capital letter.",  RPGPackage.Literals.SYSTEM_RPG__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(Buff buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(MoveE buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(AfterE buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	
	@Check
	public void checkAttribute(Attribute att) {

		if(att.getAVal().getLTypes() == null) {
			warning("This is currently not supported in the language. Please use Float or Integer instead.", RPGPackage.Literals.ATTRIBUTE__NAME, UNSUPPORTED_OPERATION);
		}
	}
	
	private Map<String, Boolean> setupBooleanDeclarationMap() {
		Map<String, Boolean> mappy = new HashMap<String, Boolean>();
		
		mappy.put("Location", false);
		mappy.put("Relations", false);
		mappy.put("Moves", false);
		mappy.put("Entities", false);
		mappy.put("Teams", false);
		mappy.put("Death", false);
		mappy.put("Attributes", false);
		mappy.put("Effects", false);
		
		return mappy;
	}
	
	private Map<String, Integer> setupIntegerDeclarationMap() {
		Map<String, Integer> mappy = new HashMap<String, Integer>();
		
		mappy.put("Location", 0);
		mappy.put("Relations", 0);
		mappy.put("Moves", 0);
		mappy.put("Entities", 0);
		mappy.put("Teams", 0);
		mappy.put("Death", 0);
		mappy.put("Attributes", 0);
		mappy.put("Effects", 0);
		
		return mappy;
	}
	
	@Check
	public void checkDeclarations(SystemRPG sysrpg) {
		// Locations | Relations | Moves | Entities | Teams | Death | Attributes | Effects
		
		Map<String, Boolean> mappy = setupBooleanDeclarationMap();
		
		for(Declaration d : sysrpg.getDeclarations()) {

			if(d instanceof Locations) {
				mappy.computeIfPresent("Location", (k, v) -> true);
			} else if(d instanceof Relations) {
				mappy.computeIfPresent("Relations", (k, v) -> true);
			} else if(d instanceof Moves) {
				mappy.computeIfPresent("Moves", (k, v) -> true);
			} else if(d instanceof Entities) {
				mappy.computeIfPresent("Entities", (k, v) -> true);
			} else if(d instanceof Teams) {
				mappy.computeIfPresent("Teams", (k, v) -> true);
			} else if(d instanceof Death) {
				mappy.computeIfPresent("Death", (k, v) -> true);
			} else if(d instanceof Attributes) {
				mappy.computeIfPresent("Attributes", (k, v) -> true);
			} else if(d instanceof Effects) {
				mappy.computeIfPresent("Effects", (k, v) -> true);
			}			
			
		}
		
		Map<String, Boolean> notPresent = mappy.entrySet().stream()
                .filter(map -> map.getValue() == false)
                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
		
		String missing = "";
		for(Map.Entry<String, Boolean> entry : notPresent.entrySet()) {
			missing += " " + "[" +entry.getKey() + "]";
		}
		
		if(notPresent.size() > 0) {
			error("The following declarations are missing:" + missing + ". Please use them in your language.", RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_DECLARATION);
		}
			


	}
	
	@Check
	public void checkDuplicateDeclarations(SystemRPG sysrpg) {
		
		Map<String, Integer> mappy = setupIntegerDeclarationMap();
		
		for(Declaration d : sysrpg.getDeclarations()) {

			if(d instanceof Locations) {
				mappy.computeIfPresent("Location", (k, v) -> v+=1);
			} else if(d instanceof Relations) {
				mappy.computeIfPresent("Relations", (k, v) -> v+=1);
			} else if(d instanceof Moves) {
				mappy.computeIfPresent("Moves", (k, v) -> v+=1);
			} else if(d instanceof Entities) {
				mappy.computeIfPresent("Entities", (k, v) -> v+=1);
			} else if(d instanceof Teams) {
				mappy.computeIfPresent("Teams", (k, v) -> v+=1);
			} else if(d instanceof Death) {
				mappy.computeIfPresent("Death", (k, v) -> v+=1);
			} else if(d instanceof Attributes) {
				mappy.computeIfPresent("Attributes", (k, v) -> v+=1);
			} else if(d instanceof Effects) {
				mappy.computeIfPresent("Effects", (k, v) -> v+=1);
			}			
			
		}
		
		Map<String, Integer> notPresent = mappy.entrySet().stream()
                .filter(map -> map.getValue() > 1)
                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
		
		String missing = "";
		for(Map.Entry<String, Integer> entry : notPresent.entrySet()) {
			missing += " " + "[" +entry.getKey() + "]";
		}
		
		if(notPresent.size() > 0) {
			error("The following declarations are duplicated:" + missing + ". Please only use one of each.", RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_DECLARATION);
		}
		
		
		
	}
	
	@Check
	public void checkTeamSize(Teams teams) {
		if(teams.getTeam().size() < 2) {
			warning("There is currently only one team, you will instantly win with no opponents.", RPGPackage.Literals.TEAMS__TEAM, INCORRECT_TEAM_COUNT);
		}
	}
	
	@Check
	public void checkAttributesAreDistinct(SystemRPG sysrpg) {
		ArrayList<String> existingAttributes = new ArrayList<>();
		HashSet<String> moveAttributes = new HashSet<>();
		HashSet<String> entityAttributes = new HashSet<>();
		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Attributes) {
				for(Attribute att : ((Attributes) dec).getAttribute()) {
					existingAttributes.add(att.getName());
				}
			} else if(dec instanceof Moves) {
				for(Move mov : ((Moves) dec).getMove()) {
					for(AltAttribute a : mov.getAtt()) {
						moveAttributes.add(a.getAttribute().getName());
					}					
				}
			} else if(dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {
					for(AltAttribute a : ent.getAtt()) {
						entityAttributes.add(a.getAttribute().getName());
					}
				}
			}
		}
		
		ArrayList<String> duplicates = new ArrayList<String>();
		
		for(String s : moveAttributes) {
			for(String d : entityAttributes) {
				if(s.equals(d)) {
					duplicates.add(d);
				}
			}
		}
		
		if(!duplicates.isEmpty()) {
			warning("Due to way the code has been implemented, using the same attribute in both an entity, and a move,"
					+ " can cause unwanted side effects, please consider changing the following duplicated attribute(s): " 
					+ duplicates, RPGPackage.Literals.SYSTEM_RPG__NAME, INDISTINCT_ATTRIBUTES);
		}
		
		
	}
	
	@Check
	public void checkDistinctEntityNames(Entities entities) {
		HashSet<String> seen = new HashSet<>();
		for(Entity e : entities.getEntity()) {
			if(seen.contains(e.getName())) {
				error("Entity names must be unique",  RPGPackage.Literals.ENTITIES__ENTITY);
			} else {
				seen.add(e.getName());
			}
		}
	}
	
	@Check
	public void checkDistinctTeamUnits(Team team) {
		HashSet<String> seen = new HashSet<>();
		for(Entity e : team.getMembers().getEntity()) {
			if(seen.contains(e.getName())) {
				error("Team entities must be unique",  RPGPackage.Literals.TEAM__NAME);
			} else {
				seen.add(e.getName());
			}
		}
	}

	@Check
	public void checkCircularExtends(Entities entities) {
		
		for(Entity e : entities.getEntity()) {
			for(Entity other_e : entities.getEntity()) {
				if(e.getName() == other_e.getName()) {
					continue;
				}
				else if(e.getExtend().getName() == null || other_e.getExtend().getName() == null) {
					continue;
				} else {
					if(e.getExtend().getName() == other_e.getName() && other_e.getName() != other_e.getExtend().getName()) {
						error("Circular dependency between: " + e.getName() + " and " + other_e.getName() + ".", RPGPackage.Literals.ENTITIES__ENTITY);
					}
				}
			}
		}
	}
	
	@Check
	public void checkAllNotExtends(Entities entities) {
		
		int extend_amount = 0;
		for(Entity e : entities.getEntity()) {
			if(e.getExtend() != null) {
				extend_amount = extend_amount + 1;
			}
		}
		
		if(entities.getEntity().size() == extend_amount) {
			error("There must be at least one entity that does not extend another entity.", RPGPackage.Literals.ENTITIES__ENTITY);
		}
	}
	
	@Check
	public void checkExtendsSelf(Entity e) {
		if(e.getExtend().getName() == e.getName()) {
			warning("Entity should not extend itself.", RPGPackage.Literals.ENTITY__EXTEND);
		}
	}
	
	@Check
	public void checkTypeIsCurrentType(Type type) {
		if(type.getName() != type.getTExpression().getCurrentT().getName()) {
			error("The type being created must be between the '<' '<'", RPGPackage.Literals.TYPE__NAME);
		}
	}
	
	@Check
	public void checkTypeWeakStrong(TypeExpression texp) {
		if(texp.getCurrentT().getName() == texp.getStrong().getName()) {
			error("The current type should not be strong against itself.", RPGPackage.Literals.TYPE_EXPRESSION__STRONG);
		}
		if(texp.getCurrentT().getName() == texp.getWeak().getName()) {
			error("The current type should not be weak against itself.", RPGPackage.Literals.TYPE_EXPRESSION__WEAK);
		}
		if(texp.getWeak().getName() == texp.getStrong().getName()) {
			error("A type should be weak and strong to a specific type.", RPGPackage.Literals.TYPE_EXPRESSION__CURRENT_T);
		}
		for(Type t : texp.getStrong2()) {
			if(texp.getCurrentT().getName() == t.getName()) {
				error("The current type should not be strong against itself.", RPGPackage.Literals.TYPE_EXPRESSION__CURRENT_T);
			}
		}
		for(Type t : texp.getWeak2()) {
			if(texp.getCurrentT().getName() == t.getName()) {
				error("The current type should not be weak against itself.", RPGPackage.Literals.TYPE_EXPRESSION__CURRENT_T);
			}
		}
		for(Type left : texp.getStrong2()) {
			for(Type right : texp.getWeak2()) {
				if(left.getName() == right.getName()) {
					error("A type should be weak and strong to a specific type.", RPGPackage.Literals.TYPE_EXPRESSION__CURRENT_T);
				}
			}
		}
	}
	
	@Check
	public void checkDuplicateRelations(Relations relations) {
		HashSet<String> seen = new HashSet<>();

		for(Type t : relations.getType()) {
			if(seen.contains(t.getName())) {
				warning("There are duplicated type declartions.", (EStructuralFeature) RPGPackage.Literals.RELATIONS);
			} else {
				seen.add(t.getName());
			}
		}
	}
	
}
