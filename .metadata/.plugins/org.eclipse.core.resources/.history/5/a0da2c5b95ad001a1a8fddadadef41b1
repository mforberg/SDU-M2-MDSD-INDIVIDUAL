/*
 * generated by Xtext 2.21.0
 */
package mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import mdsd.rPG.SystemRPG
import mdsd.rPG.Entity
import mdsd.rPG.Moves
import mdsd.rPG.Locations
import mdsd.rPG.Death
import mdsd.rPG.Require
import mdsd.rPG.Or
import mdsd.rPG.And
import mdsd.rPG.Add
import mdsd.rPG.Sub
import mdsd.rPG.Mult
import mdsd.rPG.Div
import mdsd.rPG.Comparator
import mdsd.rPG.Eq
import mdsd.rPG.Smaller
import mdsd.rPG.SmallerEq
import mdsd.rPG.NEq
import mdsd.rPG.Bigger
import mdsd.rPG.BiggerEq
import mdsd.rPG.IntNum
import mdsd.rPG.NameAttribute
import mdsd.rPG.FloatNum
import mdsd.rPG.Attributes
import mdsd.rPG.Entities
import mdsd.rPG.Declaration
import mdsd.rPG.Relations
import mdsd.rPG.Teams
import mdsd.rPG.NumberComparing
import mdsd.rPG.Team
import mdsd.rPG.Effects
import mdsd.rPG.Buff
import mdsd.rPG.MoveE
import mdsd.rPG.AfterE
import java.util.HashSet
import mdsd.rPG.AltAttribute
import mdsd.rPG.Move
import java.util.ArrayList
import mdsd.rPG.Attribute

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RPGGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val result = resource.allContents.filter(SystemRPG).next
		
		main(result, fsa)
		
	}
	
	def main(SystemRPG systemRPG, IFileSystemAccess2 fsa){	
		val classFileName = systemRPG.getName() 
		
		for (Declaration declaration : systemRPG.getDeclarations()){ 
			switch(declaration){
				Locations:
					generateLocations(fsa, declaration)
				Relations:
					generateTypes(fsa, declaration)
				Moves:
					generateMoves(fsa, declaration)
				Entities:
					generateEntities(fsa, declaration)
				Teams:
					generateTeams(fsa, declaration)
				Attributes:
					generateAttributes(fsa, declaration)
				Death:
					fsa.generateFile("DeathChecker.java", declaration.generateDeathChecker)
				Effects:
					for (Declaration dec : systemRPG.getDeclarations()) {
						if(dec instanceof Attributes) {
							var attributes = dec
							generateEffectFiles(fsa, declaration, attributes)
						}
					}
					
				default:
					System.out.println("This is not a supported instance of Declaration")
			}

		}
		fsa.generateFile(classFileName + ".java", classFileName.generateGame)
		fsa.generateFile("Runner.java", classFileName.generateRunner)
	}
	
	def CharSequence generateRunner(String name){
		'''
		import java.util.*;
		
		public class Runner {
		    public static void main(String[] args) {
		    	«name» «name.toLowerCase» = new «name»();
		    	«name.toLowerCase».run();
		    }
		}
		'''
	}
	
	def CharSequence generateDeathChecker(Death death){
		'''
		import java.util.*;
		public class DeathChecker {
			public boolean check(Entity entity){
				HashMap<String, Number> eData = new HashMap<>();
				for(AttributeData aData : entity.getAttributes()){
					eData.put(aData.getAttributeName(), aData.getNumber());
				}
				try{
					return («death.req.new_re»);
				} catch(NullPointerException e){
					System.out.println("The target seems to be invincible.");
					return false;
				}
			}
		}
		'''
	}
	
	def CharSequence generateGame(String classFileName){
		'''
		import java.util.*;
		import java.awt.event.*;
		
		public class «classFileName»{
			private Type type;
		    private List<Entity> entities;
		    private List<Entity> battleEntities;
		    private Team team;
		    private Move move;
		    private MoveInit moveInit;
		    private EntityInit entityInit;
		    private TeamInit teamInit;
		    private TypeRelation typeRelations;
		    private TypeRelationsInit typeRelationsInit;
		    private LocationsInit locationsInit;
		    private Location location;
		    private DeathChecker deathChecker;
		    private Random random;
		    
		    private String currentTeam;
		    private String hiddenCurrentLocation;
		    private boolean gameFinished;
		    private boolean won = false;
		    private boolean lost = false;
		    private Scanner s;
		    private Entity playerEntity;
		    
		    public «classFileName»(){
		    	entities = new ArrayList<>();
		    	type = Type.getInstance();
		      	team = new Team();
		    	battleEntities = new ArrayList<>();
		    	move = Move.getInstance();
		    	location = Location.getInstance();
		    	deathChecker = new DeathChecker();
		    	moveInit = new MoveInit();
		    	entityInit = new EntityInit();
		    	teamInit = new TeamInit();
		    	locationsInit = new LocationsInit();
		        typeRelations = TypeRelation.getInstance();
		        typeRelationsInit = new TypeRelationsInit();
		        s = new Scanner(System.in);
		        random = new Random();
		   	}
		   	
		   	public void run(){
		   		initialize();
		   		gameLoop();
		   	}
		   	
		   	private void initialize(){
		   		moveInit.addMoves(move);
		   		entityInit.createEntities(entities);
		   		teamInit.createTeams(team, entities);
		   		typeRelations = typeRelationsInit.createRelations();
		   		locationsInit.addLocations(location);
		   	}
		   	
		   	private void gameLoop(){
		   		playerEntity = team.getPlayerTeam().remove(0);
				while (!gameFinished) {
					if(won){
						gameFinished = true;
						System.out.println("You Won!");
					}else if(lost){
						gameFinished = true;
						System.out.println("You Lost.");
					}else{
						// Get current location to fight at
						String currentLocation = location.getLocations().remove(0);
						String enemyTeamName = location.getTeams().get(currentLocation);
						hiddenCurrentLocation = currentLocation;
						List<Entity> enemyTeam = team.getTeamByName(location.getTeams().get(currentLocation));
						System.out.println("Current Location: " + currentLocation + ", fighting against: " + enemyTeamName);
						processGame(enemyTeam);
					}
				}
		   	}
		   	
		   	private void processGame(List<Entity> enemyTeam){
		   		while(enemyTeam.size() > 0 && !lost){
		   			Entity enemyEntity = enemyTeam.remove(0);
		   			fight(enemyEntity);
		   		}
		   		if(!(location.getLocations().size() > 0) && !lost){
					won = true;
		   		}
		   	}
		   	
			private void executeBuffMove(Move move, String moveName, Entity target){
				if(!move.getMove(moveName).getBuffEffects().isEmpty()){
					for(EffectBuff buffEffect: move.getMove(moveName).getBuffEffects()){
							buffEffect.doEffect(move, moveName, target);
					}
				}
			}

			private void executeMove(Move move, String moveName, Entity target, Entity user){
				if(!move.getMove(moveName).getMoveEffects().isEmpty()){
					for(EffectMove moveEffect: move.getMove(moveName).getMoveEffects()){
						moveEffect.doEffect(move, moveName, target, user);
					}
				}
			}
			
			private void executeAfter(Move move, String moveName, Entity target){
				if(!move.getMove(moveName).getAfterEffects().isEmpty()){
					for(EffectAfter afterEffect: move.getMove(moveName).getAfterEffects()){
							afterEffect.doEffect(move, moveName, target);
					}
				}
			}		   	
		   		
		   	private void fight(Entity enemyEntity){
		   		boolean fighting = true;
		   		while(fighting){
		   			System.out.println("You are against " + enemyEntity.getName() + " choose your move");
		   			List<String> moves = playerEntity.getMoveNameList();
		   			System.out.print(playerEntity.getName() + " has: ");
					System.out.println(moves);
					
					boolean pickMove = true;
					while (pickMove){  
						String moveName = s.nextLine();
						
						// Will check that the user picks a move which exists
						if(moves.contains(moveName)){
							System.out.println("You used "+ moveName + "\n");
							HashMap<String, Number> temp = location.getEffectivenessMap().get(hiddenCurrentLocation);
							Number eff = 1;
							for (Number value : temp.values()) {
								eff = value;
							}
							System.out.println("LOOK: " + eff);
							
							executeBuffMove(move, moveName, playerEntity);
							executeMove(move, moveName, enemyEntity, playerEntity);
							executeAfter(move, moveName, playerEntity);
							
							pickMove = !pickMove;
						}else{
							System.out.println("That's not a possible move!");
						}
					}
					if(deathChecker.check(enemyEntity)){
						System.out.println(enemyEntity.getName() + " is dead!");
						enemyEntity.setEntityState(EntityState.DEAD);
						return;
					}else{
						System.out.println("Enemy Turn...");
						int choosenMove = random.nextInt(enemyEntity.getMoveNameList().size());
						System.out.println(enemyEntity.getName() + " used " + enemyEntity.getMoveNameList().get(choosenMove) + "\n");
						
						executeBuffMove(move, enemyEntity.getMoveNameList().get(choosenMove), enemyEntity);
						executeMove(move, enemyEntity.getMoveNameList().get(choosenMove), playerEntity, enemyEntity);
						executeAfter(move, enemyEntity.getMoveNameList().get(choosenMove), enemyEntity);
						
						if(deathChecker.check(playerEntity)){
							System.out.println("Your " + playerEntity.getName() + " is dead");
							playerEntity.setEntityState(EntityState.DEAD);
							
							// Will add the next player entity to the fight, if there are no more, it will go to game over
							if(!team.getPlayerTeam().isEmpty()){
								playerEntity = team.getPlayerTeam().remove(0);
							}else{
								lost = true;
								return;
							}
						}
					}
		   		}
		   	}
		}
		
		
		'''
	}
	
	def generateAttributes(IFileSystemAccess2 fsa, Attributes attributes){
        fsa.generateFile("AttributeEnum.java", attributes.generateAttributeEnum)
        fsa.generateFile("AttributeData.java", generateAttributeData)
	}
	
	def CharSequence generateAttribute(){
		'''
		import java.util.*;
		
		public class Attribute {
		    private List<AttributeData> attributes = new ArrayList<>();
		
		    private static Attribute attribute;
		
		    private Attribute() {
		
		    }
		
		    public static Attribute getInstance() {
		        if (attribute == null) {
		            attribute = new Attribute();
		        }
		        return attribute;
		    }
		
		    public void addAttribute(AttributeData attribute) {
		        attributes.add(attribute);
		    }
		    
		    public List<AttributeData> getAttributes() {
		        return attributes;
		    }
		}
		'''
	}

	def generateAttributeChangeEvent(){
		'''
		public class AttributeChangeEvent{
		  private AttributeData previousState;
		  private AttributeData targetState;
		
		  public AttributeChangeEvent(AttributeData previousState, AttributeData targetState){
		    this.previousState = previousState;
		    this.targetState = targetState;
		  }
		
		  public AttributeData getTargetState(){
		    return this.targetState;
		  }
		
		  public AttributeData getPreviousState(){
		    return this.previousState;
		  }
		
		}
		'''
	}
	
	def CharSequence generateAttributeData(){
		'''
		import java.util.*;
		public class AttributeData {
		
		    private Number number;
		    private String attributeName;
		
		    public AttributeData() {
		    }
		
		    public AttributeData(String attributeName, Number number) {
		        this.number = number;
		        this.attributeName = attributeName;
		    }
		
		    public Number getNumber() {
		        return this.number;
		    }
		
		    public void setNumber(Number number){
		        this.number = number;
		    }
		
		    public String getAttributeName() {
		        return this.attributeName;
		    }
		
		    public void setAttributeName(String attributeName) {
		        this.attributeName = attributeName;
		    }
			
			@Override
			public String toString() {
				return this.number.toString();
			}
		}
		'''
	}
	
	def generateAttributeEnum(Attributes attributes){
        '''
        public enum AttributeEnum{
        «FOR attribute: attributes.attribute »
            «attribute.name»,
        «ENDFOR»
        }
        '''
    }
    
	def generateEffectFiles(IFileSystemAccess2 fsa, Effects effects, Attributes attributes){
      	var effectBoolean = false
    	for (effect : effects.effect){
    		switch effect{
    			Buff:  {    					
    					if(!effectBoolean){
    						fsa.addEveryEffect
    						effectBoolean = true
    					}
    					fsa.generateFile(effect.name + ".java", effect.generateBuffEffectFile)
    					}
    			MoveE: {
    					if(!effectBoolean){
    						fsa.addEveryEffect
    						effectBoolean = true
    					}
    					fsa.generateFile(effect.name + ".java", generateMoveEffectFile(effect, attributes))
    					}
    			AfterE:{
    					if(!effectBoolean){
    						fsa.addEveryEffect
    						effectBoolean = true
    					}
    					fsa.generateFile(effect.name + ".java", effect.generateAfterEffetFile)
    				}
    		}
		}
	}
	
	def addEveryEffect(IFileSystemAccess2 fsa){
		fsa.generateFile("EffectBuff.java", generateEffectBuff)
		fsa.generateFile("EffectMove.java", generateEffectMove)
		fsa.generateFile("EffectAfter.java", generateEffectAfter)
	}
	
	def CharSequence generateEffectAfter(){
		'''
		public abstract class EffectAfter {

			public abstract boolean effectAfter(Move move, String name, Entity player);

			public abstract Number changeAfter(Move move, String name, Entity player);

			public abstract void doEffect(Move move, String name, Entity player);    
		}
		'''
	}
	
	def CharSequence generateAfterEffetFile(AfterE afterEffect){
		'''
			import java.util.*;
			public class «afterEffect.name» extends EffectAfter{
				
				@Override
				public boolean effectAfter(Move move, String name, Entity player){					
					«IF afterEffect.rule.or !== null»
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData playerData : player.getAttributes()){
						eData.put(playerData.getAttributeName(), playerData.getNumber());
					}			
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
						eData.put(aData.getAttributeName(), aData.getNumber());				
					}					
					return «afterEffect.rule.or.new_logic»;
					«ELSE»
					return true;					
					«ENDIF»
				}
			
				@Override
				public Number changeAfter(Move move, String name, Entity player){
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData playerData : player.getAttributes()){
							eData.put(playerData.getAttributeName(), playerData.getNumber());
						}			
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							eData.put(aData.getAttributeName(), aData.getNumber());				
						}
						return «afterEffect.rule.sum.new_exp»;
				}
			
			
				@Override		
				public void doEffect(Move move, String name, Entity player){
					if(effectAfter(move, name, player)){
						for(AttributeData aData : player.getAttributes()){
							if(aData.getAttributeName() == "«afterEffect.rule.target.name»"){
								aData.setNumber(changeAfter(move, name, player));
								System.out.println(player.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
						}
						for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							if(aData.getAttributeName() == "«afterEffect.rule.target.name»"){
								aData.setNumber(changeAfter(move, name, player));
								System.out.println(player.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());								
							}				
						}						
					}			
				}
			}		
		'''
	}
	
	def CharSequence generateEffectMove(){
			    	'''
    	import java.util.*;
    	public abstract class EffectMove {
    	
    	    public abstract boolean effectMove(Move move, String name, Entity enemy);
    	
    	    public abstract Number changeMove(Move move, String name, Entity enemy, Number modifier);
    	
    	    public abstract void doEffect(Move move, String name, Entity enemy, Entity player);    	
    	}
    	'''
		}
		
	def CharSequence generateEffectBuff(){
			    	'''
    	import java.util.*;
    	public abstract class EffectBuff {
    	
    	    public abstract boolean effectBuff(Move move, String name, Entity player);
    	
    	    public abstract Number changeBuff(Move move, String name, Entity player);
    	
    	    public abstract void doEffect(Move move, String name, Entity player);    	
    	}
    	'''
		}		
    
    def CharSequence generateBuffEffectFile(Buff buff){
    	'''
			import java.util.*;
			public class «buff.name» extends EffectBuff{
				
				@Override
				public boolean effectBuff(Move move, String name, Entity player){
					«IF buff.rule.or !== null»
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData playerData : player.getAttributes()){
						eData.put(playerData.getAttributeName(), playerData.getNumber());
					}			
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
						eData.put(aData.getAttributeName(), aData.getNumber());				
					}					
					return «buff.rule.or.new_logic»;
					«ELSE»
					return true;					
					«ENDIF»
				}
			
				@Override
				public Number changeBuff(Move move, String name, Entity player){
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData playerData : player.getAttributes()){
							eData.put(playerData.getAttributeName(), playerData.getNumber());
						}			
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							eData.put(aData.getAttributeName(), aData.getNumber());				
						}
						return «buff.rule.sum.new_exp»;
				}
				
				public Number changeAdditionalBuffs(Move move, String name, Entity enemy, String target){
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData enemyData : enemy.getAttributes()){
							eData.put(enemyData.getAttributeName(), enemyData.getNumber());
					}
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							eData.put(aData.getAttributeName(), aData.getNumber());				
					}
					«FOR r : buff.extraRule»
					if(target == "«r.target.name»") {
						return «r.sum.new_exp»;
					}
					«ENDFOR»
					return null;
				}
			
			
				@Override		
				public void doEffect(Move move, String name, Entity target){
					if(effectBuff(move, name, target)){
						for(AttributeData aData : target.getAttributes()){
							if(aData.getAttributeName() == "«buff.rule.target.name»"){
								aData.setNumber(changeBuff(move, name, target));
								System.out.println(target.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
							«FOR r : buff.extraRule»
							if(aData.getAttributeName() == "«r.target.name»"){
								aData.setNumber(changeAdditionalBuffs(move, name, target, "«r.target.name»"));
								System.out.println(target.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
							«ENDFOR»
						}
						for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							if(aData.getAttributeName() == "«buff.rule.target.name»"){
								aData.setNumber(changeBuff(move, name, target));
								System.out.println(target.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
								
							}
							«FOR r : buff.extraRule»
							if(aData.getAttributeName() == "«r.target.name»"){
								aData.setNumber(changeAdditionalBuffs(move, name, target, "«r.target.name»"));
								System.out.println(target.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
							«ENDFOR»				
						}						
					}			
				}
			}
    	'''
    }
    
	def CharSequence generateMoveEffectFile(MoveE moveE, Attributes attributes){
		var unmodifiable_attributes = new ArrayList<String>();
		
		for(Attribute a : attributes.attribute) {
			if(a.modified !== null) {
				unmodifiable_attributes.add(a.name)
			}
		}
		
    	'''
			import java.util.*;
			public class «moveE.name» extends EffectMove{
				
				TypeRelation tr = TypeRelation.getInstance();
				
				@Override
				public boolean effectMove(Move move, String name, Entity enemy){
					«IF moveE.rule.or !== null»
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData enemyData : enemy.getAttributes()){
						eData.put(enemyData.getAttributeName(), enemyData.getNumber());
					}			
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
						eData.put(aData.getAttributeName(), aData.getNumber());				
					}					
					return «moveE.rule.or.new_logic»;
					«ELSE»
					return true;					
					«ENDIF»
				}
				
				@Override
				public Number changeMove(Move move, String name, Entity enemy, Number modifier){
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData enemyData : enemy.getAttributes()){
							eData.put(enemyData.getAttributeName(), enemyData.getNumber());
						}			
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							eData.put(aData.getAttributeName(), aData.getNumber());				
						}
					«IF !unmodifiable_attributes.contains(moveE.rule.target.name)»
					return «moveE.rule.sum.new_exp» * modifier.floatValue();
					«ELSE»
					return «moveE.rule.sum.new_exp»;
					«ENDIF»
				}
				
				public Number changeAdditionalMoves(Move move, String name, Entity enemy, String target, Number modifier){
					HashMap<String, Number> eData = new HashMap<>();
					for(AttributeData enemyData : enemy.getAttributes()){
							eData.put(enemyData.getAttributeName(), enemyData.getNumber());
					}
					for(AttributeData aData : move.getMove(name).getMoveAttributes()){
							eData.put(aData.getAttributeName(), aData.getNumber());				
					}
					«FOR r : moveE.extraRule»
					«IF !unmodifiable_attributes.contains(r.target.name)»
					if(target == "«r.target.name»") {
						return «r.sum.new_exp» * modifier.floatValue();
					}
					«ELSE»
					if(target == "«r.target.name»") {
						return «r.sum.new_exp»;
					}
					«ENDIF»
					«ENDFOR»
					return null;
				}
			
				@Override		
				public void doEffect(Move move, String name, Entity target, Entity user){
					if(effectMove(move, name, user)){
						Number modifier = calculateModifier(move, name, target, user);
						// Do move effects on target
						for(AttributeData aData : target.getAttributes()){
							if(aData.getAttributeName() == "«moveE.rule.target.name»"){
								aData.setNumber(changeMove(move, name, target, modifier));
								System.out.println(target.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
							«FOR r : moveE.extraRule»
							«IF r.hits == "enemy"»
							if(aData.getAttributeName() == "«r.target.name»"){
								aData.setNumber(changeAdditionalMoves(move, name, target, "«r.target.name»", modifier));
								System.out.println(target.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
							«ENDIF»
							«ENDFOR»						
						}
						// Do move effects on user
						for(AttributeData aData : user.getAttributes()) {
							«FOR r : moveE.extraRule»
							«IF r.hits == "user"»
							if(aData.getAttributeName() == "«r.target.name»"){
								aData.setNumber(changeAdditionalMoves(move, name, user, "«r.target.name»", modifier));
								System.out.println(user.getName() + "'(s) "  + aData.getAttributeName() + " is now: " + aData.getNumber());
							}
							«ENDIF»
							«ENDFOR»
						}
					}			
				}
				
				public Number calculateModifier(Move move, String name, Entity target, Entity user) {
					Number modifier = 1.0;
					String moveType = move.getMove(name).getType();
					String targetType = target.getType();
					String userType = user.getType();
					HashMap<String, ArrayList<String>> strong = tr.getStrongMap();
					HashMap<String, ArrayList<String>> weak = tr.getWeakMap();
					System.out.println("M:" + moveType + " T: " + targetType + " U: " + userType);
					if(moveType == userType) {
						modifier = modifier.floatValue() * tr.getSyn().floatValue();
						if(strong.containsKey(moveType)) {
							ArrayList<String> strongAgainst = strong.get(moveType);
							if(strongAgainst.contains(target.getType())) {
								modifier = modifier.floatValue() * tr.getEff().floatValue();
								System.out.println("User and Move have synergy! ... It is also highly effective!");
							}	
						}
						if(weak.containsKey(moveType)) {
							ArrayList<String> weakAgainst = weak.get(moveType);
							if(weakAgainst.contains(target.getType())) {
								System.out.println("User and Move have synergy! ... But is not very effective!");
								modifier = modifier.floatValue() * tr.getIneff().floatValue();
							}	
						}
					} else {
						if(strong.containsKey(moveType)) {
							ArrayList<String> strongAgainst = strong.get(moveType);
							if(strongAgainst.contains(target.getType())) {
								modifier = modifier.floatValue() * tr.getEff().floatValue();
								System.out.println("User and Move have no synergy ... But it is highly effective!");
							}	
						}
						if(weak.containsKey(moveType)) {
							ArrayList<String> weakAgainst = weak.get(moveType);
							if(weakAgainst.contains(target.getType())) {
								modifier = modifier.floatValue() * tr.getIneff().floatValue();
								System.out.println("User and Move have no synergy ... And it is not very effective..");
							}	
						}
					}
					return modifier;
				}
			}
    	'''
    }	

	def generateEntities(IFileSystemAccess2 fsa, Entities entities){
		fsa.generateFile("Entity.java", generateEntity)
		fsa.generateFile("EntityEnum.java", entities.generateEntityEnum)
		fsa.generateFile("EntityState.java", generateEntityState)
		fsa.generateFile("EntityInit.java", entities.generateEntityInit)
	}
	
	def CharSequence generateEntity(){
		'''
		import java.util.*;
		public class Entity{
		    private String name;
		    private String type;
		    private EntityState state;
		    private List<AttributeData> attribute;
		    private List<MoveData> moves;
		
		    public Entity(){
		      attribute = new ArrayList<>();
		      moves = new ArrayList<>();
		    }
		
		    public Entity(Entity e){
		      this();
		      this.name = e.getName();
		      this.type = e.getType();
		      this.state = e.getEntityState();
		      if(!e.getAttributes().isEmpty())
		        this.attribute.addAll(e.getAttributes());
		      if(!e.getMoveData().isEmpty())
		        this.moves.addAll(e.getMoveData());
		    }
		
		    public String getName(){
		      return this.name;
		    }
		    public void setName(String name){
		      this.name = name;
		    }
		    public String getType(){
		      return this.type;
		    }
		    public void setType(String type){
		      this.type = type;
		    }
		    public List<AttributeData> getAttributes(){
		      return attribute;
		    }
		
		    public EntityState getEntityState(){
		      return state;
		    }
		
		    public void setEntityState(EntityState state){
		      this.state = state;
		    }
		
		    public void addAttribute(AttributeData attribute){
		      this.attribute.add(attribute);
		    }
		
		    public List<MoveData> getMoveData(){
		      return moves;
		    }
		
		    public List<String> getMoveNameList(){
		      List<String> moveNames = new ArrayList<>();
		      for (MoveData moveData : getMoveData()) {
		          moveNames.add(moveData.getMoveName());
		      }
		      return moveNames;
		    }
		    
		    public void addMoveData(MoveData moveData){
		      moves.add(moveData);
		    }
		}
		'''
	}
	
	def CharSequence generateEntityEnum(Entities entities){
		var entityEnum = ""
		var i = 1
		for(entity : entities.entity){
			entityEnum += entity.name
			if(i < entities.entity.size){
				entityEnum += ", "
				i++
			} else {
				entityEnum += ";"
			}
		}
		'''
		enum EntityEnum{
			«entityEnum»
		}
		'''
		
	}
	
	def CharSequence generateEntityState(){
		'''
		public enum EntityState {
		    DEAD, ALIVE
		}
		'''
	}
	
	def CharSequence generateEntityInit(Entities entities){
		'''
		import java.util.*;
		
		public class EntityInit{
			public void createEntities(List<Entity> entities){
				createStandardEntities(entities);
				createExtendedEntities(entities);
			}
			
			public void createStandardEntities(List<Entity> entities) {
				«FOR entity : entities.entity»
				«IF entity.extend === null »
				Entity «entity.name.toLowerCase» = new Entity();
				«entity.name.toLowerCase».setName("«entity.name»");
				«entity.name.toLowerCase».setType("«entity.EType.type.name»");
				«FOR move : entity.EMoves.move»
				«entity.name.toLowerCase».addMoveData(Move.getInstance().getMove("«move.name»"));
				«ENDFOR»
				«FOR att : entity.att»
				«entity.name.toLowerCase».addAttribute(new AttributeData("«att.attribute.name»", «getNumberValue(att.av.an)»));
				«ENDFOR»
				entities.add(«entity.name.toLowerCase»);
				«ENDIF»
				«ENDFOR»
			}
			
			public void createExtendedEntities(List<Entity> entities) {
				«FOR entity : entities.entity»
				«IF entity.extend !== null»
				Entity «entity.name.toLowerCase» = new Entity();
				«entity.name.toLowerCase».setName("«entity.name»");
				«entity.name.toLowerCase».setType("«entity.EType.type.name»");
				«FOR move : entity.EMoves.move»
				«entity.name.toLowerCase».addMoveData(Move.getInstance().getMove("«move.name»"));
				«ENDFOR»
				«FOR att : entity.att»
				«entity.name.toLowerCase».addAttribute(new AttributeData("«att.attribute.name»", «getNumberValue(att.av.an)»));
				«ENDFOR»
				«addExtendedStuff(entity, entities)»
				entities.add(«entity.name.toLowerCase»);
				«ENDIF»
				«ENDFOR»
			}
		}
		
		'''
	}
	
	def CharSequence addExtendedStuff(Entity currentEntity, Entities allEntities) {
		val observed_move = new HashSet<String>();
		val observed_attribute = new HashSet<String>();
		
		for(Move m : currentEntity.EMoves.move) {
			observed_move.add(m.name)
		}
		for(AltAttribute a : currentEntity.att){
			observed_attribute.add(a.attribute.name)
		}
		
		'''
		«FOR new_entity : allEntities.entity»
		«IF currentEntity.extend.name === new_entity.name»
		«FOR move : new_entity.EMoves.move»
		«IF !observed_move.contains(move.name)»
		«currentEntity.name.toLowerCase».addMoveData(Move.getInstance().getMove("«move.name»"));
		«ENDIF»
		«FOR att : new_entity.att»
		«IF !observed_attribute.contains(att.attribute.name)»
		«currentEntity.name.toLowerCase».addAttribute(new AttributeData("«att.attribute.name»", «getNumberValue(att.av.an)»));
		«ENDIF»
		«ENDFOR»
		«ENDFOR»
		«ENDIF»
		«ENDFOR»
		'''
	}
	
	def CharSequence new_re(Require req){
		req.log.new_logic
	}
	
	def generateComp(Comparator op) {
		switch op { Eq: '==' Smaller: '<' Bigger: '>' SmallerEq: '<=' BiggerEq: '>=' NEq: '!=' }
	}

	def dispatch CharSequence new_logic(Or x){
		'''(«x.left.new_logic»||«x.right.new_logic»)'''
	}
	def dispatch CharSequence new_logic(And x){
		'''(«x.left.new_logic»&&«x.right.new_logic»)'''
	}
	def dispatch CharSequence new_logic(NumberComparing x){
		'''(«x.left.new_exp»«x.comp.generateComp»«x.right.new_exp»)'''
	}
	def dispatch CharSequence new_exp(Add x){
		'''(«x.left.new_exp»+«x.right.new_exp»)'''
	}
	def dispatch CharSequence new_exp(Sub x){
		'''(«x.left.new_exp»-«x.right.new_exp»)'''
	}
	def dispatch CharSequence new_exp(Mult x){
		'''(«x.left.new_exp»*«x.right.new_exp»)'''
	}
	def dispatch CharSequence new_exp(Div x){
		'''(«x.left.new_exp»/«x.right.new_exp»)'''
	}
	def dispatch CharSequence new_exp(IntNum x){
		Integer.toString(x.value)
	}
	def dispatch CharSequence new_exp(FloatNum x){
		Integer.toString(x.i) + '.' + Integer.toString(x.decimal)
	}
	def dispatch CharSequence new_exp(NameAttribute x){
		if(x.attribute.AVal.LTypes !== null && x.attribute.AVal.LTypes.equals("Integer")){
			"eData.get(" + '"' +x.attribute.name + '"' + ").intValue()"
		}else if(x.attribute.AVal.LTypes !== null && x.attribute.AVal.LTypes.equals("Float")){ 
			"eData.get(" + '"' +x.attribute.name + '"' + ").floatValue()"
		}else if(x.attribute.AVal.an !== null && x.attribute.AVal.an instanceof IntNum){
			"eData.get(" + '"' +x.attribute.name + '"' + ").intValue()"
		}else if(x.attribute.AVal.an !== null && x.attribute.AVal.an instanceof FloatNum){
			"eData.get(" + '"' +x.attribute.name + '"' + ").floatValue()"
		} else {
			"Something went wrong" 
		}
	}
	
	def dispatch Number getNumberValue(IntNum x){
		x.value
	}
	def dispatch Number getNumberValue(FloatNum x){
		val floatstring = x.i + "." + x.decimal
		Float.valueOf(floatstring)
	}
	
	def generateLocations(IFileSystemAccess2 fsa, Locations locations){
		fsa.generateFile("Location.java", locations.generateLocation)
		fsa.generateFile("LocationsInit.java", locations.generateLocationInit)
	}
	
	def CharSequence generateLocation(Locations locations){
		
		'''
		import java.util.*;
		
		public class Location {
		    private List<String> locations;
		    private String currentLocation;
		    private String currentTeam;
		    
			private HashMap<String, HashMap<String, Number>> effectivenessMap;
		    private Map<String, String> teams;
		
		    private static Location location;    
		
		    private Location(){
		        locations = new ArrayList<>();
		        teams = new HashMap<>();
				effectivenessMap = new HashMap<>();
		    }
		
		    public static Location getInstance(){
		        if(location == null){
		            location = new Location();
		        }
		        return location;
		    }
		    
		    public HashMap<String, HashMap<String, Number>> getEffectivenessMap() {
		    	return effectivenessMap;
		    }
		    
		    public void addEffectiveness(String location, String tipe, Number n) {
				HashMap<String, Number> temp = new HashMap<>();
				temp.put(tipe, n);
				effectivenessMap.put(location, temp);
		    }
		
		    public String getCurrentLocation(){
		        return this.currentLocation;
		    }
		
		    public String getCurrentTeam(){
		        return this.currentTeam;
		    }
		
		    public Map<String, String> getTeams(){
		        return this.teams;
		    }
		
		    public List<String> getLocations(){
		        return this.locations;
		    }
		
		    public void setLocations(List<String> locations){
		        this.locations = locations;
		    }
		
		    public void setCurrentLocation(String currentLocation){
		        this.currentLocation = currentLocation;
		    }
		
		    public void addLocation(String location){
		        locations.add(location);
		    }
		
		    public void addTeamToLocation(String location, String team){
		        if(locations.contains(location)){
		            teams.put(location, team);
		        } else {
		        	addLocation(location);
		        	teams.put(location, team);
		        }
		    }
		
		
		}
		'''
	}
	
	def CharSequence generateLocationInit(Locations locations){
		'''
		import java.util.*;
		
		public class LocationsInit{
			public void addLocations(Location location){
				String locationName;
				String teamName;
				Number currentEffectiveness;
				String tipe;
				«FOR location : locations.loc»
				locationName = "«location.name»";
				teamName = "«location.team.name»";
				«IF location.tipe !== null»
				tipe = "«location.tipe.name»";
				currentEffectiveness = «getNumberValue(location.eff)»;
				location.addEffectiveness(locationName, tipe, currentEffectiveness);
				«ENDIF»
				location.addTeamToLocation(locationName, teamName);
				«ENDFOR»
			}
		}
		'''
	}
	
	def generateMoves(IFileSystemAccess2 fsa, Moves moves){
		fsa.generateFile("Move.java", generateMove)
		fsa.generateFile("MoveEnum.java", moves.generateMoveEnum)
		fsa.generateFile("MoveInit.java", moves.generateMoveInit)
		fsa.generateFile("MoveData.java", generateMoveData)
	}
	
	def CharSequence generateMove(){
		'''
		import java.util.*;
				
		public class Move{			
		
			private static Move move;
			private List<MoveData> moves = new ArrayList<>();
			
			private Move(){}
		
			public static Move getInstance(){
				if (move == null){
					move = new Move();
				}
				return move;
			}
		
			public void addMove(MoveData move){
				moves.add(move);
			}
		
			public MoveData getMove(String move){
				MoveData mD = null;
		
				for (MoveData moveData : moves) {
					if(moveData.getMoveName().equals(move)){
						mD = moveData;
					}
				}
				return mD;
			}
		
			public List<MoveData> getMoves(){
				return moves;
			}
		
		}
			
		'''
		
	}
	
	def CharSequence generateMoveData(){
		'''
		import java.util.*;
		
		public class MoveData{
		
		    private String moveName;
			private String type;
		    private List<AttributeData> moveAttributes;
		    private List<EffectMove> moveEffects;
		    private List<EffectBuff> buffEffects;
		    private List<EffectAfter> afterEffects;
		
		    public MoveData(){
		        this.moveAttributes = new ArrayList<>();
				this.moveEffects = new ArrayList<>();
				this.buffEffects = new ArrayList<>();
				this.afterEffects = new ArrayList<>();
		    }
		
		    public MoveData(String moveName, String type, List<AttributeData> moveAttributes, List<EffectMove> moveEffects, List<EffectBuff> buffEffects, List<EffectAfter> afterEffects) {
		        this.moveName = moveName;
		        this.type = type;
		        this.moveAttributes = moveAttributes;
				this.moveEffects = moveEffects;
				this.buffEffects = buffEffects;
				this.afterEffects = afterEffects;	
		    }
		
		    public String getMoveName(){
		        return this.moveName;
		    }
		
		    public void setMoveName(String moveName) {
		        this.moveName = moveName;
		    }
		
		    public String getType() {
		        return this.type;
		    }
		
		    public void setType(String type) {
		        this.type = type;
		    }
		
		    public List<AttributeData> getMoveAttributes() {
		        return this.moveAttributes;
		    }
		
		    public void setMoveAttributes(List<AttributeData> moveAttributes) {
		        this.moveAttributes = moveAttributes;
		    }
		
		    public void addAttribute(AttributeData attribute){
		        moveAttributes.add(attribute);
		    }
			
			public List<EffectBuff> getBuffEffects(){
				return this.buffEffects;
			}
			
			public List<EffectMove> getMoveEffects(){
				return this.moveEffects;
			}
			
			public List<EffectAfter> getAfterEffects(){
				return this.afterEffects;
			}
			
			public void addMoveEffect(EffectMove moveEffect){
				this.moveEffects.add(moveEffect);
			}
			
			public void addBuffEffect(EffectBuff buffEffect){
				this.buffEffects.add(buffEffect);
			}
			
			public void addAfterEffect(EffectAfter afterEffect){
				this.afterEffects.add(afterEffect);
			}
		
		    @Override
		    public boolean equals(Object o) {
		        if (o == this)
		            return true;
		        if (!(o instanceof MoveData)) {
		            return false;
		        }
		        MoveData moveData = (MoveData) o;
		        return Objects.equals(moveName, moveData.moveName) && Objects.equals(type, moveData.type) && Objects.equals(moveAttributes, moveData.moveAttributes);
		    }
		
		    @Override
		    public int hashCode() {
		        return Objects.hash(moveName, type, moveAttributes, moveEffects, buffEffects, afterEffects);
		    }
		
		    @Override
		    public String toString() {
		        return getMoveName();
		    }
		
		}
		'''
	}

	def CharSequence generateMoveEnum(Moves moves){
		var moveEnums = ""
		var i = 1
		for(move : moves.move){
			var name = move.name
			var type = move.getEType().type.name
			moveEnums += name
			moveEnums += "(" + '"' + type + '"' + ')'
			if(i < moves.move.size){
				moveEnums += ", "
				i++
			} else {
				moveEnums += ";"
			}
		}
		
		'''
		enum MoveEnum{
		    «moveEnums»
		    private String type;
		
		    private MoveEnum(String type){
		        this.type = type;
		    }
		
		    public String getType(){
		        return this.type;
		    }
		}
		'''
	}
	
	def CharSequence generateMoveInit(Moves moves){
		'''
		import java.util.*;
		
		public class MoveInit{
			public void addMoves(Move moves){ //private Move moves = Move.getInstance()
				MoveData tempMoveData;
				«FOR move : moves.move»
				tempMoveData = new MoveData();
				tempMoveData.setMoveName("«move.name»");
				tempMoveData.setType("«move.EType.type.name»");
				«FOR att : move.att»
				tempMoveData.addAttribute(new AttributeData("«att.attribute.name»", «getNumberValue(att.av.an)»));
				«ENDFOR»
				«FOR moveEffect : move.MEffect»
				«IF moveEffect !== null»
				tempMoveData.addMoveEffect(new «moveEffect.moveEName.name»());
				«ENDIF»
				«ENDFOR»
				«FOR buffEffect : move.BEffect»
				«IF buffEffect !== null»
				tempMoveData.addBuffEffect(new «buffEffect.buffEName.name»());
				«ENDIF»
				«ENDFOR»
				«FOR afterEffect : move.AEffect»
				«IF afterEffect !== null»
				tempMoveData.addAfterEffect(new «afterEffect.afterEName.name»());
				«ENDIF»
				«ENDFOR»				
				moves.addMove(tempMoveData);
				«ENDFOR»
			}
		}
		'''
	}
	
	def generateTeams(IFileSystemAccess2 fsa, Teams teams){
		fsa.generateFile("Team.java", generateTeam)
		fsa.generateFile("TeamInit.java", teams.generateTeamInit)
	}
	
	def String addTeamMemberString(Team team){
		var createTeamString = "team.addTeamMember(" + '"' + team.name + '"' + ", "
		var i = 1
		for(Entity e : team.members.entity){
			createTeamString += "findEntityByName(" + '"'+ e.name + '"' + ", entities" + ")"
			if(team.members.entity.size() > i){
				i++
				createTeamString += ", "
			} else {
				createTeamString += ");"
			}
		}
		createTeamString
	}
	
	def CharSequence generateTeam(){
		'''
		import java.util.*;
		
		public class Team {
		    private Map<String, List<Entity>> teams;
		    private List<String> teamNames;
		
		    public Team() {
		        teams = new HashMap<>();
		        teamNames = new ArrayList<>(); 
		    }
		
		    public List<Entity> getTeamByName(String name) {
		        if (!teams.containsKey(name)) {
		            return null;
		        }
		        return teams.get(name);
		    }
		
		    public void addTeamMember(String team, Entity... entity) {
		        if (!teams.containsKey(team)) {
		            teams.put(team, entityAdder(entity));
		            teamNames.add(team);
		        } else {
		            teams.get(team).addAll(entityAdder(entity));
		        }
		    }
		
		    public List<Entity> entityAdder(Entity... entity) {
		        List<Entity> eList = new ArrayList<>();
		        for (Entity entity2 : entity) {
		            Entity tempEntity = new Entity(entity2);
		            eList.add(tempEntity);
		        }
		        return eList;
		    }
		
		    public Map<String, List<Entity>> getTeams(){
		        return teams;
		    }
		
		    public List<Entity> getPlayerTeam(){
		        return teams.get(teamNames.get(0));
		    }
		
		    public boolean checkPlayerEntities(){
		        int playerTeamSize = getPlayerTeam().size();
		        int deadEntities = 0;
		        for (Entity entity : getPlayerTeam()) {
		            if(entity.getEntityState() == EntityState.DEAD) break;
		            deadEntities++;
		            if(deadEntities == playerTeamSize) return true;
		        }
		        return false;
		    }
		
		    public int playerEntitiesAlive(){
		        int alive = 0;
		        for (Entity entity : getPlayerTeam()) {
		            if(entity.getEntityState() != EntityState.DEAD) alive++;
		        }
		        return alive;
		    }
		}
		'''
	}
	
	def CharSequence generateTeamInit(Teams teams){
		'''
		import java.util.*;
		
		public class TeamInit{
			public void createTeams(Team team, List<Entity> entities){
				«FOR team : teams.team»
				«addTeamMemberString(team)»
				«ENDFOR»
			}
			
			private Entity findEntityByName(String name, List<Entity> entities){
				for(Entity e : entities){
					if(e.getName().equals(name)){
						return e;
					}
				}
				return null;
			}
		}
		
		
		
		
		'''
	}
	
	def generateTypes(IFileSystemAccess2 fsa, Relations relations){
		fsa.generateFile("Type.java", generateType)
		fsa.generateFile("TypeEnum.java", relations.generateTypeEnum)
		fsa.generateFile("TypeRelation.java", relations.generateTypeRelation)
		fsa.generateFile("TypeRelationsInit.java", relations.generateTypeInit)
	}
	
	def CharSequence generateTypeRelation(Relations relations){

		
		'''
		import java.util.*;
				
				public class TypeRelation {
					
					private HashMap<String, ArrayList<String>> weakMap;
					private HashMap<String, ArrayList<String>> strongMap;
					
					«IF relations.syn !== null»
					private Number synergyModifier = «getNumberValue(relations.syn)»;
					private Number effectiveModifier = «getNumberValue(relations.eff)»;
					private Number ineffectiveModifier = «getNumberValue(relations.ineff)»;
					«ELSE»
					private Number synergyModifier = 1.5;
					private Number effectiveModifier = 1.5;
					private Number ineffectiveModifier = 0.5;
					«ENDIF»
				    
				    private static TypeRelation tr;
				
				    public TypeRelation(){
				        weakMap = new HashMap<>();
				        strongMap = new HashMap<>();
				    }
				    
					public static TypeRelation getInstance(){
						if(tr == null){
							tr = new TypeRelation();
						}
						return tr;
					}
				    
				    
				    public void addToW(String target, ArrayList<String> value) {
						weakMap.put(target, value);
				    }
				    
				    public void addToS(String target, ArrayList<String> value) {
						strongMap.put(target, value);
				    }
				    
				    public HashMap<String, ArrayList<String>> getWeakMap() {
				    	return weakMap;
				    }
				    
				    public HashMap<String, ArrayList<String>> getStrongMap() {
				    	return strongMap;
				    }
				    
				    public Number getSyn() {
				    	return synergyModifier;
				    }
				    
				    public Number getEff() {
				    	return effectiveModifier;
				    }
				    
				    public Number getIneff() {
				    	return ineffectiveModifier;
				    }
				
				}
		'''
	}
	
	def CharSequence generateTypeInit(Relations relations){
		
		'''
		import java.util.*;
				
		public class TypeRelationsInit{
			
			
			public TypeRelation createRelations(){
				TypeRelation tr = TypeRelation.getInstance();
				
				«FOR t : relations.type»
				«IF t.TExpression !== null»
				ArrayList<String> «t.name»StrongList = new ArrayList<String>();
				ArrayList<String> «t.name»WeakList = new ArrayList<String>();
				«t.name»StrongList.add("«t.TExpression.strong.name»");
				«t.name»WeakList.add("«t.TExpression.weak.name»");
				«FOR moreStrong : t.TExpression.strong2»
				«t.name»StrongList.add("«moreStrong.name»");
				«ENDFOR»
				«FOR worse : t.TExpression.weak2»
				«t.name»WeakList.add("«worse.name»");
				«ENDFOR»
				tr.addToS("«t.name»", «t.name»StrongList);
				tr.addToW("«t.name»", «t.name»WeakList);

				
				«ENDIF»
				«ENDFOR»
				
				return tr;
			}
		}
		'''
	}
	
	def CharSequence generateType(){
		'''
		import java.util.*;
				
		public class Type{
				
			private List<String> types = new ArrayList<>();
			private HashMap<String, TypeRelation> typeRelations = new HashMap<>();
		
			private static Type type;
					
			private Type(){}
		
			public static Type getInstance(){
				if(type == null){
					type = new Type();
				}
				return type;
			}
							
			public void addType(String type){
				types.add(type);
			}
		
			public List<String> getTypes(){
				return types;
			}
		
			public void addTypeRelation(String typeString, TypeRelation tr){
				typeRelations.put(typeString, tr);
			}
		
			public HashMap<String, TypeRelation> getTypeRelations(){
				return typeRelations;
			}
		}
		'''
	}

	def generateTypeEnum(Relations relations){
        '''
        public enum TypeEnum{
        «FOR type: relations.type »
            «type.name»,
        «ENDFOR»
        }
        '''
    }
	
}
